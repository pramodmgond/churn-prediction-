# -*- coding: utf-8 -*-
"""sampleapp

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1emjZlnPVNKc8t3UOgSyElZLL95ip21zm
"""

import numpy as np
import pickle
import pandas as pd
import seaborn as sns
#from flasgger import Swagger
import streamlit as st 
import sklearn
from sklearn.neighbors import KNeighborsClassifier
from PIL import Image
import plotly.express as px
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler, MinMaxScaler
from sklearn.preprocessing import LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.tree import DecisionTreeClassifier
from sklearn.metrics import confusion_matrix
from sklearn.svm import SVC
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, confusion_matrix

label_encoder = LabelEncoder()

#app=Flask(__name__)
#Swagger(app)

pickle_in = open("mdl.pkl","rb")
classifier=pickle.load(pickle_in)

#@app.route('/')
def welcome():
    return "Welcome All"

#@app.route('/predict',methods=["Get"])
def predict_churn(tenure,PhoneService,Contract,PaperlessBilling,PaymentMethod,MonthlyCharges,TotalCharges,gender,SeniorCitizen,Partner,Dependents,MultipleLines,InternetService,OnlineSecurity,OnlineBackup,DeviceProtection,TechSupport,StreamingTV,StreamingMovies):
    prediction=classifier.predict([[tenure,PhoneService,Contract,PaperlessBilling,PaymentMethod,MonthlyCharges,TotalCharges,gender,SeniorCitizen,Partner,Dependents,MultipleLines,InternetService,OnlineSecurity,OnlineBackup,DeviceProtection,TechSupport,StreamingTV,StreamingMovies]])
    print(prediction)
    return prediction
    
def main():
  st.title("Telecom customer churn prediction")
  html_temp = """
    <div style="background-color: #006400;padding:10px">
    <h2 style="color:white;text-align:center;"> Predict whether a particular customer will switch to another telecom 
provider or not.</h2>
    </div>
    """
  
  

  st.markdown(html_temp,unsafe_allow_html=True)


   # Create a file uploader
  file = st.file_uploader("Upload a file", type=["csv", "xlsx"])
    
    # Check if the user has uploaded a file
  if file is not None:
        # Use Pandas to read the file
        data = pd.read_csv(file) # Replace with pd.read_excel() if uploading an Excel file
        
        # Show the data on the app
        st.write(data)
  
  # Display first 5 rows of data
        st.write("Data head:")
        st.dataframe(data.head())

        st.subheader('To Check Columns Name')
# show column names
        if st.checkbox("Show Column Names"):
           st.write(data.columns)
           # show dimensions
        if st.checkbox("Show Dimensions"):
           st.write(data.shape)
          
        st.subheader('Summaery of the Data')     
# show summary
        if st.checkbox("Show Summary"):
           st.write(data.describe())
           numeric_columns = data.select_dtypes(include=['int', 'float'])
           st.subheader('Check null values and fill null values ')   
# show missing values
        if st.checkbox("Show Missing Values"):
           st.write(numeric_columns.isna().sum())

# Select a column to treat missing values
           col_option = st.multiselect("Select Feature to fillna",numeric_columns.columns)

# Specify options to treat missing values
           Replace=" "
           col_option1=" "
          
           missing_values_clear=""
           missing_values_clear = st.selectbox("Select Missing values treatment method", ("Replace with Mean", "Replace with Median", "Replace with Mode"))

        if missing_values_clear == "Replace with Mean":
           replaced_value = data[col_option].mean()
           data[col_option]=data[col_option].mean()
           st.write("Mean value of column is :", replaced_value)
        elif missing_values_clear == "Replace with Median":
           replaced_value = data[col_option].median()
           st.write("Median value of column is :", replaced_value)
        elif missing_values_clear == "Replace with Mode":
           replaced_value = data[col_option].mode()
           st.write("Mode value of column is :", replaced_value)

           Replace = st.selectbox("Replace values of column?", ("Yes", "No"))
        if Replace == "Yes":
           data[col_option] = data[col_option].fillna(replaced_value,)
           st.write("Null values replaced")
        elif Replace == "No":
           st.write("No changes made")

           st.subheader(' Check Null values Categorical Columns and fill Null values  ')
#only categorical columns
           object_columns = data.select_dtypes(include=['object'])
        if st.checkbox("Show Missing Values of object columns"):
          

      
# Specify options to treat missing values
           missing_values_clear = None # default value

# code to get user input and update missing_values_clear variable

        if missing_values_clear is None:
           st.warning("Please select a method to handle missing values.")
        else:
    # code to handle missing values based on selected method

           missing_values_clear = st.selectbox("Select Missing values For Categorycal columns treatment method", ("Replace with Mean", "Replace with Median", "Replace with Mode"))

        if missing_values_clear == "Replace with Mean":
           replaced_value1 = data[col_option1].mean()
    
           st.write("Mean value of column is :", replaced_value1)
        elif missing_values_clear == "Replace with Median":
           replaced_value1 = data[col_option1].median()
           st.write("Median value of column is :", replaced_value1)
        elif missing_values_clear == "Replace with Mode":
           replaced_value1 ='Missinig'
    
           st.write("Mode value of column is :", replaced_value1)

           data = np.array(data).astype(float)
           
# To change datatype of a column in a dataframe
# display datatypes of all columns
        if st.checkbox("Show datatypes of the columns"):
           st.write(data.dtypes)

           st.subheader('Convert Datatype')
           col_option_datatype = st.multiselect("Select Column to change datatype", data.columns) 

           input_data_type = st.selectbox("Select Datatype of input column", (str,int, float))  
           output_data_type = st.selectbox("Select Datatype of output column", (label_encoder,'OneHot_encode'))

           st.write("Datatype of ",col_option_datatype," changed to ", output_data_type)
        if output_data_type=='OneHot_encode':
           for i in col_option_datatype:
              data = pd.get_dummies(data, columns=[i],drop_first=True)
        
        else:
           for i in col_option_datatype:
              data[i] = output_data_type.fit_transform(data[i])
        if st.checkbox("Show updated datatypes of the columns"):
           st.write(data.dtypes)
        if st.checkbox("Preview Dataset aftre convert datatype"):
           if st.button("Head "):
              st.write(data.head())

# visualization
           st.subheader('Box Plot')
# scatter plot
# Get column names
           col_names = list(data.columns)
    
# Let user select a column to plot
           selected_col = st.selectbox("Select a column to plot", col_names)
    
# Plot count plot
           fig, ax = plt.subplots()
           ax = sns.countplot(x=selected_col, data=data,ax=ax)
           
           st.pyplot(fig)
           fig.savefig("countplot.png")
           st.subheader('Correlation Plot') 
# correlartion plots
           if st.checkbox("Show Correlation plots with Seaborn"):
              st.write(sns.heatmap(data.corr()))
              st.pyplot()
            
            
              st.subheader('Feature_Scaling')
              scaling_method = st.selectbox('Select a scaling method:', ['Standardization', 'Normalization'])

# Perform the selected scaling method on the dataset
           if scaling_method == 'Standardization':
              scaler = StandardScaler()
              scaled_data = scaler.fit_transform(data)
           else:
              scaler = MinMaxScaler()
              scaled_data = scaler.fit_transform(data)
# Display the scaled data
              st.write('Scaled data:')
              st.write(pd.DataFrame(scaled_data, columns=data.columns))
# Machine Learning Algorithms
              st.subheader('Machine Learning models')

              features = st.multiselect("Select Feature Columns",data.columns)
              labels = st.multiselect("select target column",data.columns)

              features= data[features].values
              labels = data[labels].values

              train_percent = st.slider("Select % to train model", 1, 100)
              train_percent = train_percent/100

              X_train,X_test, y_train, y_test = train_test_split(features, labels, train_size=train_percent, random_state=1)

              alg = ['Support Vector Machine', 'Random Forest Classifier','KNN Classifier']
              classifier = st.selectbox('Which algorithm?', alg)

              if classifier == 'Support Vector Machine':
                 svm=SVC()
                 svm.fit(X_train, y_train)
                 acc = svm.score(X_test, y_test)
                 st.write('Accuracy: ', acc)
                 pred_svm = svm.predict(X_test)
                 cm=confusion_matrix(y_test,pred_svm)
                 st.write('Confusion matrix: ', cm)

              elif classifier == 'Random Forest Classifier':
                 RFC=RandomForestClassifier()
                 RFC.fit(X_train, y_train)
                 acc = RFC.score(X_test, y_test)
                 st.write('Accuracy: ', acc)
                 pred_RFC = RFC.predict(X_test)
                 cm=confusion_matrix(y_test,pred_RFC)
                 st.write('Confusion matrix: ', cm)
              
              elif classifier == 'KNN Classifier':
                 k = st.sidebar.slider('Select K', 1, 10)
                 knn = KNeighborsClassifier(n_neighbors=k)
                 knn.fit(X_train, y_train)
                 y_pred = knn.predict(X_test)
                 accuracy = accuracy_score(y_test, y_pred)
                 st.write('Accuracy: ', accuracy)
                 cm = confusion_matrix(y_test, y_pred)
                 st.write('Confusion matrix: ', cm)
        
  display = ("Male","Female")
  options = list(range(len(display)))
  value = st.selectbox("Gender", options, format_func=lambda x: display[x])
  gender=value
  
  display = ("0","1")
  options = list(range(len(display)))
  value = st.selectbox("SeniorCitizen", options, format_func=lambda x: display[x])
  SeniorCitizen=value
  
  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Partner", options, format_func=lambda x: display[x])
  Partner=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Dependents", options, format_func=lambda x: display[x])
  Dependents=value
    
  tenure = st.text_input("Enter tenure","Type Here")

  display = ("Yes", "No")
  options = list(range(len(display)))
  value = st.selectbox("Phone service", options, format_func=lambda x: display[x])
  PhoneService=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Multiple lines", options, format_func=lambda x: display[x])
  MultipleLines=value

  display = ("DSL","FIBER OPTIC","No")
  options = list(range(len(display)))
  value = st.selectbox("Type of internet service", options, format_func=lambda x: display[x])
  InternetService=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Online Security", options, format_func=lambda x: display[x])
  OnlineSecurity=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Online Backup", options, format_func=lambda x: display[x])
  OnlineBackup=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Device protection", options, format_func=lambda x: display[x])
  DeviceProtection=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Tech support", options, format_func=lambda x: display[x])
  TechSupport=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Streaming tv", options, format_func=lambda x: display[x])
  StreamingTV=value

  display = ("Yes","No")
  options = list(range(len(display)))
  value = st.selectbox("Streaming movies", options, format_func=lambda x: display[x])
  StreamingMovies=value

  display = ("Month-to-Month", "One year","Two year")
  options = list(range(len(display)))
  value = st.selectbox("Contract type", options, format_func=lambda x: display[x])
  Contract=value

  display = ("Yes", "No")
  options = list(range(len(display)))
  value = st.selectbox("Type of billing?", options, format_func=lambda x: display[x])
  PaperlessBilling=value

  display = ("Bank transfer (automatic)", "Credit card (automatic)","Electronic check","Mailed check")
  options = list(range(len(display)))
  value = st.selectbox("Mode of payment?", options, format_func=lambda x: display[x])
  PaymentMethod=value
    
  MonthlyCharges = st.text_input("Monthly charges","Type Here")
    
  TotalCharges = st.text_input("Total charges","Type Here")

  result=""
  if st.button("Predict"):   
    tenure=float(tenure)
    PhoneService=float(PhoneService)
    Contract=float(Contract)
    PaperlessBilling=float(PaperlessBilling)
    PaymentMethod=float(PaymentMethod)
    MonthlyCharges=float(MonthlyCharges)
    TotalCharges=float(TotalCharges)
    gender=float(gender)
    SeniorCitizen=float(SeniorCitizen)
    Partner=float(Partner)
    Dependents=float(Dependents)
    MultipleLines=float(MultipleLines)
    InternetService=float(InternetService)
    OnlineSecurity=float(OnlineSecurity)
    OnlineBackup=float(OnlineBackup)
    DeviceProtection=float(DeviceProtection)
    TechSupport=float(TechSupport)
    StreamingTV=float(StreamingTV)
    StreamingMovies=float(StreamingMovies)
    
    result=predict_churn(tenure,PhoneService,Contract,PaperlessBilling,PaymentMethod,MonthlyCharges,TotalCharges,gender,SeniorCitizen,Partner,Dependents,MultipleLines,InternetService,OnlineSecurity,OnlineBackup,DeviceProtection,TechSupport,StreamingTV,StreamingMovies)
  st.success('The status is {}'.format(result))
  if st.button("About"):
    st.text("Lets LEarn")
    st.text("Built with Streamlit")

if __name__=='__main__':
    main()

